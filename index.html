<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>✦ Mandala Studio</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=Raleway:wght@300;400;500&display=swap');

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --panel-bg: rgba(8, 8, 20, 0.85);
    --panel-border: rgba(180, 140, 255, 0.18);
    --accent: #b87fff;
    --accent2: #7fd4ff;
    --accent3: #ff9de2;
    --text: rgba(230, 220, 255, 0.9);
    --text-dim: rgba(180, 160, 220, 0.55);
    --btn-bg: rgba(255,255,255,0.06);
    --btn-active: rgba(180,140,255,0.28);
    --radius: 12px;
    --panel-w: 242px;
  }

  html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: #000;
    font-family: 'Raleway', sans-serif;
    color: var(--text);
  }

  canvas {
    display: block;
    position: fixed;
    top: 0; left: 0;
    cursor: crosshair;
    touch-action: none;
  }

  /* ─── PANEL ─── */
  #panel {
    position: fixed;
    top: 16px; left: 16px;
    width: var(--panel-w);
    max-height: calc(100vh - 32px);
    overflow-y: auto;
    overflow-x: hidden;
    background: var(--panel-bg);
    border: 1px solid var(--panel-border);
    border-radius: var(--radius);
    padding: 14px 14px 16px;
    backdrop-filter: blur(18px);
    -webkit-backdrop-filter: blur(18px);
    z-index: 100;
    user-select: none;
    transition: transform 0.3s cubic-bezier(.4,0,.2,1), opacity 0.3s ease;
    box-shadow: 0 8px 40px rgba(0,0,0,0.65), 0 0 0 1px rgba(255,255,255,0.04) inset;
    scrollbar-width: none;
  }
  #panel::-webkit-scrollbar { display: none; }
  #panel.collapsed {
    transform: translateX(calc(-100% - 24px));
    opacity: 0;
    pointer-events: none;
  }

  #panel-title {
    font-family: 'Cinzel', serif;
    font-size: 13px; font-weight: 600;
    letter-spacing: 0.12em;
    color: var(--accent);
    text-align: center;
    margin-bottom: 12px;
    text-shadow: 0 0 14px rgba(180,140,255,0.6);
  }

  .section {
    margin-bottom: 12px;
    padding-bottom: 12px;
    border-bottom: 1px solid rgba(255,255,255,0.06);
  }
  .section:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }

  label {
    display: flex; justify-content: space-between; align-items: center;
    font-size: 10.5px; font-weight: 500;
    letter-spacing: 0.06em;
    color: var(--text-dim);
    margin-bottom: 5px;
    text-transform: uppercase;
  }
  label span { color: var(--accent); font-weight: 400; }

  input[type=range] {
    -webkit-appearance: none;
    width: 100%; height: 3px;
    background: rgba(255,255,255,0.1);
    border-radius: 2px; outline: none;
    margin: 4px 0 8px;
  }
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px; height: 14px; border-radius: 50%;
    background: var(--accent); cursor: pointer;
    box-shadow: 0 0 8px rgba(180,140,255,0.7);
  }
  input[type=range]::-moz-range-thumb {
    width: 14px; height: 14px; border-radius: 50%;
    background: var(--accent); cursor: pointer;
    border: none; box-shadow: 0 0 8px rgba(180,140,255,0.7);
  }

  .color-row { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
  #colorPicker {
    -webkit-appearance: none;
    width: 36px; height: 28px;
    border: none; border-radius: 6px;
    padding: 2px; cursor: pointer; background: transparent;
  }
  #colorPicker::-webkit-color-swatch-wrapper { padding: 0; }
  #colorPicker::-webkit-color-swatch { border: none; border-radius: 5px; }

  .swatches { display: flex; flex-wrap: wrap; gap: 5px; flex: 1; }
  .swatch {
    width: 16px; height: 16px; border-radius: 50%; cursor: pointer;
    border: 1.5px solid rgba(255,255,255,0.12);
    transition: transform 0.15s, box-shadow 0.15s;
  }
  .swatch:hover { transform: scale(1.3); box-shadow: 0 0 8px currentColor; }
  .swatch.active { border-color: #fff; transform: scale(1.2); }

  .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; }
  .btn-grid-3 { grid-template-columns: 1fr 1fr 1fr; }

  .btn {
    background: var(--btn-bg);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 7px; color: var(--text);
    font-family: 'Raleway', sans-serif;
    font-size: 10px; font-weight: 500;
    letter-spacing: 0.04em;
    padding: 7px 4px; cursor: pointer; text-align: center;
    transition: background 0.15s, border-color 0.15s, color 0.15s, box-shadow 0.15s;
    min-height: 30px;
    display: flex; align-items: center; justify-content: center;
    line-height: 1.2;
  }
  .btn:hover { background: rgba(255,255,255,0.1); border-color: rgba(255,255,255,0.2); }
  .btn.active {
    background: var(--btn-active); border-color: var(--accent); color: var(--accent);
    box-shadow: 0 0 10px rgba(180,140,255,0.25);
  }
  .btn.danger { color: #ff7eb3; border-color: rgba(255,126,179,0.2); }
  .btn.danger:hover { background: rgba(255,126,179,0.12); border-color: rgba(255,126,179,0.5); }
  .btn.success { color: var(--accent2); border-color: rgba(127,212,255,0.2); }
  .btn.success:hover { background: rgba(127,212,255,0.1); border-color: rgba(127,212,255,0.5); }

  .sym-btns { display: flex; gap: 4px; flex-wrap: wrap; }
  .sym-btn {
    flex: 1; min-width: 26px;
    background: var(--btn-bg);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 6px; color: var(--text-dim);
    font-size: 10px; font-weight: 600;
    padding: 5px 2px; cursor: pointer; text-align: center;
    transition: all 0.15s; font-family: 'Cinzel', serif;
  }
  .sym-btn:hover { color: var(--text); border-color: var(--accent); }
  .sym-btn.active {
    background: var(--btn-active); border-color: var(--accent);
    color: var(--accent); box-shadow: 0 0 8px rgba(180,140,255,0.3);
  }

  select {
    width: 100%; background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 7px; color: var(--text);
    font-family: 'Raleway', sans-serif;
    font-size: 10.5px; padding: 6px 8px;
    outline: none; cursor: pointer; appearance: none;
  }
  select option { background: #111; }

  /* ─── TOGGLE BUTTON ─── */
  #togglePanel {
    position: fixed;
    top: 16px; left: 16px;
    width: 40px; height: 40px;
    background: var(--panel-bg);
    border: 1px solid var(--panel-border);
    border-radius: 10px;
    backdrop-filter: blur(18px);
    -webkit-backdrop-filter: blur(18px);
    cursor: pointer;
    z-index: 200;
    display: flex; align-items: center; justify-content: center;
    font-size: 18px;
    transition: opacity 0.3s, transform 0.3s;
    box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    opacity: 0;
    pointer-events: none;
    transform: scale(0.8);
  }
  #togglePanel.visible { opacity: 1; pointer-events: auto; transform: scale(1); }

  #hint {
    position: fixed;
    bottom: 20px; left: 50%; transform: translateX(-50%);
    background: rgba(8,8,20,0.78);
    border: 1px solid rgba(180,140,255,0.15);
    border-radius: 20px; padding: 8px 18px;
    font-size: 11px; color: var(--text-dim);
    letter-spacing: 0.06em; backdrop-filter: blur(10px);
    pointer-events: none; transition: opacity 1s; z-index: 50;
    white-space: nowrap;
  }

  #pinCount {
    position: fixed; bottom: 60px; right: 20px;
    background: var(--panel-bg); border: 1px solid var(--panel-border);
    border-radius: 10px; padding: 8px 14px;
    font-size: 11px; color: var(--accent);
    backdrop-filter: blur(10px); display: none; z-index: 50;
    font-family: 'Cinzel', serif; letter-spacing: 0.08em;
  }

  #spiralControls { display: none; margin-top: 8px; }

  @media (max-width: 480px) {
    :root { --panel-w: 220px; }
    #panel { top: 10px; left: 10px; padding: 10px; }
  }
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<!-- Floating button shown when panel is hidden -->
<div id="togglePanel" title="Show Controls" onclick="showPanel()">✦</div>

<div id="panel">
  <div id="panel-title">✦ MANDALA STUDIO ✦</div>

  <div class="section">
    <label>Drawing Mode</label>
    <div class="btn-grid" style="margin-bottom:5px">
      <div class="btn active" id="modeSymmetry" onclick="setMode('symmetry')">⬡ Mandala</div>
      <div class="btn" id="modeFree" onclick="setMode('free')">✏ Free Draw</div>
    </div>
    <div class="btn-grid" style="margin-bottom:5px">
      <div class="btn" id="modeString" onclick="setMode('string')">⬤ String Art</div>
      <div class="btn" id="modeSpiral" onclick="setMode('spiral')">◎ Spiral</div>
    </div>
    <div class="btn-grid">
      <div class="btn" id="modePolygon" onclick="setMode('polygon')">⬡ Polygon</div>
      <div class="btn" id="modeErase" onclick="setMode('erase')">◌ Erase</div>
    </div>
  </div>

  <div class="section" id="symSection">
    <label>Symmetry Axes</label>
    <div class="sym-btns">
      <div class="sym-btn" onclick="setSymmetry(4)">4</div>
      <div class="sym-btn active" onclick="setSymmetry(6)">6</div>
      <div class="sym-btn" onclick="setSymmetry(8)">8</div>
      <div class="sym-btn" onclick="setSymmetry(10)">10</div>
      <div class="sym-btn" onclick="setSymmetry(12)">12</div>
      <div class="sym-btn" onclick="setSymmetry(16)">16</div>
    </div>
  </div>

  <div class="section">
    <label>Color</label>
    <div class="color-row">
      <input type="color" id="colorPicker" value="#b87fff" oninput="setColor(this.value)">
      <div class="swatches" id="swatches"></div>
    </div>
  </div>

  <div class="section">
    <label>Brush Size <span id="sizeVal">3</span>px</label>
    <input type="range" id="brushSize" min="1" max="40" value="3"
      oninput="document.getElementById('sizeVal').textContent=this.value">
    <label>Opacity <span id="opacVal">0.85</span></label>
    <input type="range" id="opacity" min="0.05" max="1" step="0.05" value="0.85"
      oninput="document.getElementById('opacVal').textContent=parseFloat(this.value).toFixed(2)">
    <label style="margin-top:2px">Line Cap</label>
    <select id="lineCap">
      <option value="round" selected>Round</option>
      <option value="butt">Butt</option>
      <option value="square">Square</option>
    </select>
  </div>

  <div class="section">
    <label>Visual FX</label>
    <div class="btn-grid">
      <div class="btn active" id="glowBtn" onclick="toggleGlow()">✦ Glow</div>
      <div class="btn" id="animBtn" onclick="toggleAnim()">⟳ Rotate</div>
    </div>
  </div>

  <div id="spiralControls" class="section">
    <label>Spiral Angle <span id="spiralAngleVal">137.5°</span></label>
    <input type="range" id="spiralAngle" min="5" max="180" step="0.5" value="137.5"
      oninput="document.getElementById('spiralAngleVal').textContent=parseFloat(this.value).toFixed(1)+'°'">
    <label>Scale Step <span id="spiralScaleVal">0.97</span></label>
    <input type="range" id="spiralScale" min="0.85" max="0.999" step="0.001" value="0.97"
      oninput="document.getElementById('spiralScaleVal').textContent=parseFloat(this.value).toFixed(3)">
  </div>

  <div class="section">
    <label>Background</label>
    <div class="btn-grid btn-grid-3">
      <div class="btn active" id="bgBlack" onclick="setBg('black')">◼ Dark</div>
      <div class="btn" id="bgWhite" onclick="setBg('white')">◻ Light</div>
      <div class="btn" id="bgGrad" onclick="setBg('grad')">◈ Cosmos</div>
    </div>
  </div>

  <!-- View / Camera -->
  <div class="section">
    <label>View <span id="zoomLabel">100%</span></label>
    <div class="btn-grid btn-grid-3" style="margin-bottom:5px">
      <div class="btn" onclick="stepZoom(1.2)">＋ In</div>
      <div class="btn" onclick="stepZoom(1/1.2)">－ Out</div>
      <div class="btn" onclick="resetView()">⊙ Reset</div>
    </div>
    <div style="font-size:9px; color:var(--text-dim); text-align:center; letter-spacing:0.05em; line-height:1.6;">
      Scroll wheel = zoom<br>MMB / Right-drag = pan
    </div>
  </div>

  <div class="section">
    <div class="btn-grid" style="margin-bottom:5px">
      <div class="btn danger" onclick="clearCanvas()">✕ Clear</div>
      <div class="btn" onclick="undo()">↩ Undo</div>
    </div>
    <div class="btn-grid">
      <div class="btn success" onclick="saveImage()">↓ Save PNG</div>
      <div class="btn" onclick="hidePanel()">⊡ Hide UI</div>
    </div>
  </div>
</div>

<div id="hint">Draw · Scroll=zoom · MMB/RMB drag=pan · ✦ to show controls</div>
<div id="pinCount">0 pins placed</div>

<script>
// ═══════════════════════════════════════════════════════════════════════
//  MANDALA STUDIO — Infinite Canvas Edition
// ═══════════════════════════════════════════════════════════════════════
//
//  KEY ARCHITECTURE: Vector Stroke History
//  ────────────────────────────────────────
//  All artwork is stored as an array of "command" objects in `history[]`.
//  Each command stores world-space coordinates + drawing parameters.
//  On every render, renderAll() replays every command after applying the
//  current camera transform → infinite pan/zoom with zero quality loss.
//
//  COORDINATE SPACES
//  ─────────────────
//  Screen space  : raw pixel position on the <canvas> element.
//  World space   : logical space where the mandala center = (0, 0).
//                  Independent of zoom, pan, and rotation.
//
//  screenToWorld(sx, sy):
//    1. Subtract screen center + pan offset, divide by zoom → base world pos
//    2. Un-rotate by camera.rotation so drawing is in the mandala frame
//       (new strokes automatically rotate with the existing artwork)
//
//  applyCameraTransform():
//    ctx.translate(screenCenter + pan), ctx.rotate(rotation), ctx.scale(zoom)
//    After this, drawing in world coords appears correctly on screen.
// ═══════════════════════════════════════════════════════════════════════

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });

// ─── CAMERA ──────────────────────────────────────────────────────────
const camera = {
  panX: 0,      // world origin offset from screen center, in screen pixels
  panY: 0,
  zoom: 1,      // world-unit to screen-pixel ratio
  rotation: 0,  // global art rotation (radians), animated by Rotate mode
};

// ─── APP STATE ───────────────────────────────────────────────────────
let mode = 'symmetry';
let symmetry = 6;
let currentColor = '#b87fff';
let glowEnabled = true;
let animEnabled = false;
let bgMode = 'black';
let spiralStrokeCount = 0;   // increments each time a spiral stroke is committed

// ─── HISTORY & UNDO ──────────────────────────────────────────────────
// history  : array of committed drawing commands (world space)
// undoStack: array of snapshots of `history` for multi-step undo
let history = [];
const undoStack = [];
const MAX_UNDO = 10;

// liveStroke: the stroke currently being drawn (appended to history on pointerup)
let isDrawing = false;
let liveStroke = null;

// ─── PAN DRAG STATE ──────────────────────────────────────────────────
let isPanning = false;
let panStart = { x: 0, y: 0, px: 0, py: 0 };

// ─── STRING ART & POLYGON STATE ──────────────────────────────────────
let pins = [];        // current session pins (world-space {x,y})
let polyPoints = [];  // in-progress polygon vertices (world-space {x,y})

// ─── ANIMATION RAF ───────────────────────────────────────────────────
let animRAF = null;

// Render scheduling (coalesces multiple rapid updates into one frame)
let renderPending = false;

// ─── SEEDED RNG (star field) ─────────────────────────────────────────
function mulberry32(seed) {
  let a = seed;
  return () => {
    a |= 0; a = a + 0x6D2B79F5 | 0;
    let t = Math.imul(a ^ a >>> 15, 1 | a);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

// ─────────────────────────────────────────────────────────────────────
//  PALETTE & UI INIT
// ─────────────────────────────────────────────────────────────────────

const PALETTE = [
  '#ff6eb4','#ff9de2','#ffcb8e','#fff07a',
  '#a8ff78','#7fd4ff','#b87fff','#ffffff',
  '#ff4d6d','#00f5d4','#f7b731','#fd9644'
];

function buildSwatches() {
  const container = document.getElementById('swatches');
  container.innerHTML = '';
  PALETTE.forEach(c => {
    const s = document.createElement('div');
    s.className = 'swatch' + (c === currentColor ? ' active' : '');
    s.style.background = c;
    s.onclick = () => {
      currentColor = c;
      try { document.getElementById('colorPicker').value = c; } catch(e) {}
      document.querySelectorAll('.swatch').forEach(el => el.classList.remove('active'));
      s.classList.add('active');
    };
    container.appendChild(s);
  });
}
buildSwatches();

function setColor(v) {
  currentColor = v;
  document.querySelectorAll('.swatch').forEach(el => el.classList.remove('active'));
}

// ─────────────────────────────────────────────────────────────────────
//  COORDINATE TRANSFORMS
// ─────────────────────────────────────────────────────────────────────

function screenCX() { return canvas.width / 2; }
function screenCY() { return canvas.height / 2; }

/**
 * Convert screen-space (mouse/touch) position → world space.
 *
 * Steps:
 *  1. Remove screen center + pan → gives unscaled world coords
 *  2. Divide by zoom → world coords at rotation=0
 *  3. Un-rotate by camera.rotation → world coords in the mandala's own frame
 *     This ensures new strokes are always drawn in the same frame as existing
 *     art, so they rotate together when camera.rotation changes.
 */
function screenToWorld(sx, sy) {
  let wx = (sx - screenCX() - camera.panX) / camera.zoom;
  let wy = (sy - screenCY() - camera.panY) / camera.zoom;

  if (camera.rotation !== 0) {
    const cos = Math.cos(-camera.rotation);
    const sin = Math.sin(-camera.rotation);
    const rx = wx * cos - wy * sin;
    const ry = wx * sin + wy * cos;
    wx = rx; wy = ry;
  }
  return { x: wx, y: wy };
}

/**
 * Apply camera transform to ctx.
 * Call after ctx.save(). All subsequent drawing in world coords will appear
 * correctly on screen.
 *
 * Transform order (applied right-to-left):
 *   1. scale(zoom)       — world units → screen pixels
 *   2. rotate(rotation)  — global art rotation
 *   3. translate(cx+pan) — move world origin to screen center + pan
 */
function applyCameraTransform() {
  ctx.translate(screenCX() + camera.panX, screenCY() + camera.panY);
  ctx.rotate(camera.rotation);
  ctx.scale(camera.zoom, camera.zoom);
}

// ─────────────────────────────────────────────────────────────────────
//  ZOOM & PAN
// ─────────────────────────────────────────────────────────────────────

/**
 * Zoom centered on a specific screen point (sx, sy).
 * Adjusts panX/panY so the world point under the cursor stays fixed.
 */
function zoomAt(sx, sy, factor) {
  // Find the world-space point under cursor before zoom change
  const wx = (sx - screenCX() - camera.panX) / camera.zoom;
  const wy = (sy - screenCY() - camera.panY) / camera.zoom;

  camera.zoom = Math.min(40, Math.max(0.04, camera.zoom * factor));

  // Re-adjust pan so that world point (wx,wy) stays at screen (sx,sy)
  camera.panX = sx - screenCX() - wx * camera.zoom;
  camera.panY = sy - screenCY() - wy * camera.zoom;

  updateZoomLabel();
  scheduleRender();
}

function stepZoom(factor) {
  zoomAt(canvas.width / 2, canvas.height / 2, factor);
}

function resetView() {
  camera.panX = 0; camera.panY = 0;
  camera.zoom = 1; camera.rotation = 0;
  animEnabled = false;
  document.getElementById('animBtn').classList.remove('active');
  if (animRAF) { cancelAnimationFrame(animRAF); animRAF = null; }
  updateZoomLabel();
  scheduleRender();
}

function updateZoomLabel() {
  document.getElementById('zoomLabel').textContent = Math.round(camera.zoom * 100) + '%';
}

// ─────────────────────────────────────────────────────────────────────
//  ROTATION ANIMATION
//  Increments camera.rotation each RAF. renderAll() is called each frame.
//  Drawing while rotating works because screenToWorld() un-rotates the
//  cursor position back to mandala frame — new strokes land correctly.
// ─────────────────────────────────────────────────────────────────────

function startAnim() {
  if (animRAF) return;
  function loop() {
    if (!animEnabled) { animRAF = null; return; }
    camera.rotation += 0.0018;  // ~0.1°/frame → slow meditative spin
    renderAll();
    animRAF = requestAnimationFrame(loop);
  }
  animRAF = requestAnimationFrame(loop);
}

function stopAnim() {
  animEnabled = false;
  if (animRAF) { cancelAnimationFrame(animRAF); animRAF = null; }
}

function toggleAnim() {
  animEnabled = !animEnabled;
  document.getElementById('animBtn').classList.toggle('active', animEnabled);
  if (animEnabled) startAnim(); else stopAnim();
}

// ─────────────────────────────────────────────────────────────────────
//  RENDER SCHEDULING
// ─────────────────────────────────────────────────────────────────────

function scheduleRender() {
  if (renderPending) return;
  renderPending = true;
  requestAnimationFrame(() => { renderPending = false; renderAll(); });
}

// ─────────────────────────────────────────────────────────────────────
//  BACKGROUND
// ─────────────────────────────────────────────────────────────────────

function drawBg() {
  // Fill screen first (no transform — always covers full viewport)
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);

  if (bgMode === 'black') {
    ctx.fillStyle = '#050510';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  } else if (bgMode === 'white') {
    ctx.fillStyle = '#f8f5ff';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  } else {
    // Cosmos: radial gradient from screen center
    const g = ctx.createRadialGradient(
      canvas.width / 2, canvas.height / 2, 0,
      canvas.width / 2, canvas.height / 2,
      Math.max(canvas.width, canvas.height) * 0.72
    );
    g.addColorStop(0, '#0d0730');
    g.addColorStop(0.5, '#070220');
    g.addColorStop(1, '#000005');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
  ctx.restore();

  // Stars: drawn in world space so they pan/zoom naturally
  if (bgMode === 'grad') {
    ctx.save();
    applyCameraTransform();
    const rand = mulberry32(42);
    for (let i = 0; i < 400; i++) {
      const x = (rand() - 0.5) * 8000;
      const y = (rand() - 0.5) * 8000;
      const r = (rand() * 1.4 + 0.2) / camera.zoom;
      ctx.globalAlpha = rand() * 0.6 + 0.15;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
    ctx.restore();
  }
}

// ─────────────────────────────────────────────────────────────────────
//  GUIDE CIRCLE (subtle helper, world space)
// ─────────────────────────────────────────────────────────────────────

function drawGuide() {
  ctx.save();
  applyCameraTransform();
  const r = 280;
  ctx.globalAlpha = 0.05;
  ctx.strokeStyle = '#b87fff';
  ctx.lineWidth = 1 / camera.zoom;
  ctx.setLineDash([4 / camera.zoom, 8 / camera.zoom]);
  ctx.beginPath();
  ctx.arc(0, 0, r, 0, Math.PI * 2);
  ctx.stroke();
  for (let i = 0; i < symmetry; i++) {
    const a = (Math.PI * 2 / symmetry) * i;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
    ctx.stroke();
  }
  ctx.setLineDash([]);
  ctx.globalAlpha = 1;
  ctx.restore();
}

// ─────────────────────────────────────────────────────────────────────
//  MAIN RENDER — replays the full history
// ─────────────────────────────────────────────────────────────────────

function renderAll() {
  // Full clear
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();

  drawBg();
  drawGuide();

  // Replay committed history
  for (const cmd of history) {
    replayCommand(cmd);
  }

  // Overlay the in-progress stroke
  if (liveStroke && liveStroke.points.length > 1) {
    replayCommand(liveStroke);
  }

  // Polygon preview
  if (mode === 'polygon' && polyPoints.length > 0) {
    drawPolyPreview();
  }
}

// ─────────────────────────────────────────────────────────────────────
//  COMMAND REPLAY
// ─────────────────────────────────────────────────────────────────────

function replayCommand(cmd) {
  ctx.save();
  applyCameraTransform();   // world → screen

  if (cmd.type === 'stroke')  replayStroke(cmd);
  else if (cmd.type === 'pin') replayPins(cmd);
  else if (cmd.type === 'polygon') replayPolygon(cmd);

  ctx.restore();
}

/**
 * Replay a drawn stroke.
 *
 * SYMMETRY mode:
 *   Loop `symmetry` times, each iteration rotates by (2π/symmetry)*i,
 *   draws the stroke, then mirrors it by scale(1,-1) and draws again.
 *   This produces the classic mandala reflection pattern.
 *
 * SPIRAL mode:
 *   Each stroke stored with its spiralStrokeIndex. On replay, 20 copies
 *   are drawn each rotated by (index + i) * goldenAngle and scaled down
 *   by spiralScale^i — creating the golden-ratio phyllotaxis spiral.
 *
 * ERASE mode:
 *   Uses destination-out compositing. Since we fully re-render from
 *   history every frame, erase commands reliably remove art beneath them.
 */
function replayStroke(cmd) {
  if (cmd.points.length < 2) return;
  const pts = cmd.points;

  ctx.lineCap = cmd.lineCap;
  ctx.lineJoin = 'round';
  ctx.globalAlpha = cmd.opacity;

  // Line width is stored in world units; divide by zoom keeps screen width stable
  const lw = cmd.size / camera.zoom;

  if (cmd.mode === 'erase') {
    ctx.globalCompositeOperation = 'destination-out';
    ctx.lineWidth = lw * 3;
    ctx.strokeStyle = 'rgba(0,0,0,1)';
    ctx.shadowBlur = 0;
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
    ctx.stroke();
    return;
  }

  if (cmd.mode === 'symmetry') {
    // ── Mandala symmetry: rotate + mirror for each axis ──
    ctx.lineWidth = lw;
    ctx.strokeStyle = cmd.color;
    if (cmd.glow) { ctx.shadowColor = cmd.color; ctx.shadowBlur = 14 / camera.zoom; }

    const slice = (Math.PI * 2) / cmd.symmetry;
    for (let s = 0; s < cmd.symmetry; s++) {
      ctx.save();
      ctx.rotate(slice * s);

      // Original sector
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.stroke();

      // Mirrored sector (flip y = reflect across x-axis)
      ctx.save();
      ctx.scale(1, -1);
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.stroke();
      ctx.restore();

      ctx.restore();
    }

  } else if (cmd.mode === 'free') {
    ctx.lineWidth = lw;
    ctx.strokeStyle = cmd.color;
    if (cmd.glow) { ctx.shadowColor = cmd.color; ctx.shadowBlur = 14 / camera.zoom; }
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
    ctx.stroke();

  } else if (cmd.mode === 'spiral') {
    // ── Spiral / Phyllotaxis: 20 rotated+scaled copies per stroke ──
    const REPEATS = 20;
    const angleRad = (cmd.spiralAngleDeg * Math.PI) / 180;
    const baseRot = cmd.spiralStrokeIndex * angleRad;
    if (cmd.glow) { ctx.shadowBlur = 12 / camera.zoom; }
    let scale = 1;

    for (let i = 0; i < REPEATS; i++) {
      ctx.save();
      ctx.rotate(baseRot + i * angleRad);
      ctx.scale(scale, scale);

      // Shift hue across copies for rainbow effect
      const hue = (i / REPEATS * 360 + cmd.spiralStrokeIndex * 5) % 360;
      ctx.strokeStyle = `hsl(${hue}, 90%, 65%)`;
      if (cmd.glow) ctx.shadowColor = ctx.strokeStyle;
      ctx.lineWidth = lw * scale;

      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for (let j = 1; j < pts.length; j++) ctx.lineTo(pts[j].x, pts[j].y);
      ctx.stroke();
      ctx.restore();

      scale *= cmd.spiralScale;
    }
    ctx.shadowBlur = 0;
  }
}

/**
 * Replay string-art pin connections.
 * Draws lines between every pair of pins with rainbow hues.
 */
function replayPins(cmd) {
  const n = cmd.pins.length;
  if (n === 0) return;

  ctx.lineWidth = 0.8 / camera.zoom;
  ctx.lineCap = 'round';
  ctx.globalAlpha = cmd.opacity * 0.7;

  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      const hue  = ((i / n) * 300 + i * 13) % 360;
      const hue2 = ((j / n) * 300 + j * 13) % 360;
      ctx.shadowColor = `hsl(${hue}, 90%, 65%)`;
      ctx.shadowBlur = cmd.glow ? 8 / camera.zoom : 0;
      ctx.strokeStyle = `hsl(${hue}, 90%, 65%)`;
      ctx.beginPath();
      ctx.moveTo(cmd.pins[i].x, cmd.pins[i].y);
      ctx.lineTo(cmd.pins[j].x, cmd.pins[j].y);
      ctx.stroke();
    }
  }

  // Pin dots
  ctx.globalAlpha = 1;
  ctx.fillStyle = '#fff';
  ctx.shadowColor = '#fff';
  ctx.shadowBlur = cmd.glow ? 5 / camera.zoom : 0;
  for (const p of cmd.pins) {
    ctx.beginPath();
    ctx.arc(p.x, p.y, 3 / camera.zoom, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.shadowBlur = 0;
}

/**
 * Replay a committed polygon with radial symmetry.
 */
function replayPolygon(cmd) {
  if (cmd.points.length < 3) return;
  const slice = (Math.PI * 2) / cmd.symmetry;
  ctx.globalAlpha = cmd.opacity;
  ctx.strokeStyle = cmd.color;
  ctx.fillStyle = cmd.color + '22';
  ctx.lineWidth = cmd.size / camera.zoom;
  ctx.lineCap = cmd.lineCap;
  ctx.lineJoin = 'round';
  if (cmd.glow) { ctx.shadowColor = cmd.color; ctx.shadowBlur = 14 / camera.zoom; }

  for (let i = 0; i < cmd.symmetry; i++) {
    ctx.save();
    ctx.rotate(slice * i);
    // Draw original + y-mirror
    for (const flip of [1, -1]) {
      ctx.save();
      ctx.scale(1, flip);
      ctx.beginPath();
      ctx.moveTo(cmd.points[0].x, cmd.points[0].y);
      for (let j = 1; j < cmd.points.length; j++) ctx.lineTo(cmd.points[j].x, cmd.points[j].y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }
    ctx.restore();
  }
  ctx.shadowBlur = 0;
}

/**
 * Draw the in-progress polygon outline (not yet committed).
 */
function drawPolyPreview() {
  if (polyPoints.length === 0) return;
  ctx.save();
  applyCameraTransform();

  ctx.globalAlpha = 0.55;
  ctx.strokeStyle = currentColor;
  ctx.lineWidth = 1.5 / camera.zoom;
  ctx.setLineDash([4 / camera.zoom, 4 / camera.zoom]);
  ctx.beginPath();
  ctx.moveTo(polyPoints[0].x, polyPoints[0].y);
  for (let i = 1; i < polyPoints.length; i++) ctx.lineTo(polyPoints[i].x, polyPoints[i].y);
  ctx.stroke();

  ctx.setLineDash([]);
  ctx.fillStyle = currentColor;
  ctx.globalAlpha = 0.9;
  if (glowEnabled) { ctx.shadowColor = currentColor; ctx.shadowBlur = 8 / camera.zoom; }
  for (const p of polyPoints) {
    ctx.beginPath();
    ctx.arc(p.x, p.y, 4 / camera.zoom, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.shadowBlur = 0;
  ctx.restore();
}

// ─────────────────────────────────────────────────────────────────────
//  UNDO SYSTEM
//  Snapshots history[] before each new action using JSON deep-copy.
//  On undo, restores the previous snapshot.
// ─────────────────────────────────────────────────────────────────────

function pushUndo() {
  if (undoStack.length >= MAX_UNDO) undoStack.shift();
  undoStack.push(JSON.parse(JSON.stringify(history)));
}

function undo() {
  if (undoStack.length === 0) return;
  history = undoStack.pop();

  // Recompute derived state from restored history
  spiralStrokeCount = history.filter(c => c.type === 'stroke' && c.mode === 'spiral').length;
  const lastPin = [...history].reverse().find(c => c.type === 'pin');
  pins = lastPin ? lastPin.pins.map(p => ({ ...p })) : [];
  updatePinCount();
  scheduleRender();
}

// ─────────────────────────────────────────────────────────────────────
//  CLEAR
// ─────────────────────────────────────────────────────────────────────

function clearCanvas() {
  pushUndo();
  history = [];
  pins = [];
  polyPoints = [];
  spiralStrokeCount = 0;
  liveStroke = null;
  isDrawing = false;
  updatePinCount();
  scheduleRender();
}

// ─────────────────────────────────────────────────────────────────────
//  SETTINGS SNAPSHOT
// ─────────────────────────────────────────────────────────────────────

function getSettings() {
  return {
    size:          +document.getElementById('brushSize').value,
    opacity:       +document.getElementById('opacity').value,
    lineCap:        document.getElementById('lineCap').value,
    spiralAngleDeg: +document.getElementById('spiralAngle').value,
    spiralScale:    +document.getElementById('spiralScale').value,
  };
}

// ─────────────────────────────────────────────────────────────────────
//  MODE & UI CONTROLS
// ─────────────────────────────────────────────────────────────────────

function setMode(m) {
  mode = m;
  ['Symmetry','Free','String','Spiral','Polygon','Erase'].forEach(n => {
    document.getElementById('mode' + n)?.classList.remove('active');
  });
  document.getElementById('mode' + m.charAt(0).toUpperCase() + m.slice(1))?.classList.add('active');

  document.getElementById('spiralControls').style.display =
    m === 'spiral' ? 'block' : 'none';
  document.getElementById('symSection').style.display =
    (m === 'symmetry' || m === 'polygon') ? 'block' : 'none';

  document.getElementById('pinCount').style.display = m === 'string' ? 'block' : 'none';
  polyPoints = [];
  scheduleRender();
}

function setSymmetry(n) {
  symmetry = n;
  document.querySelectorAll('.sym-btn').forEach((b, i) => {
    b.classList.toggle('active', [4,6,8,10,12,16][i] === n);
  });
}

function toggleGlow() {
  glowEnabled = !glowEnabled;
  document.getElementById('glowBtn').classList.toggle('active', glowEnabled);
  scheduleRender();
}

function setBg(b) {
  bgMode = b;
  ['bgBlack','bgWhite','bgGrad'].forEach(id => document.getElementById(id).classList.remove('active'));
  document.getElementById({ black: 'bgBlack', white: 'bgWhite', grad: 'bgGrad' }[b]).classList.add('active');
  scheduleRender();
}

// ─────────────────────────────────────────────────────────────────────
//  PANEL TOGGLE — Fixed
//  hidePanel() slides panel away and reveals the floating ✦ button.
//  showPanel() is called directly by the ✦ button's onclick attribute.
// ─────────────────────────────────────────────────────────────────────

function hidePanel() {
  document.getElementById('panel').classList.add('collapsed');
  document.getElementById('togglePanel').classList.add('visible');
}

function showPanel() {
  document.getElementById('panel').classList.remove('collapsed');
  document.getElementById('togglePanel').classList.remove('visible');
}

// ─────────────────────────────────────────────────────────────────────
//  STRING ART
// ─────────────────────────────────────────────────────────────────────

function addPin(wx, wy) {
  pushUndo();
  pins.push({ x: wx, y: wy });
  updatePinCount();
  const s = getSettings();
  history.push({
    type: 'pin',
    pins: pins.map(p => ({ ...p })),  // snapshot of all pins so far
    opacity: s.opacity,
    glow: glowEnabled,
  });
  scheduleRender();
}

function updatePinCount() {
  const el = document.getElementById('pinCount');
  el.textContent = `${pins.length} pin${pins.length !== 1 ? 's' : ''} placed`;
}

// ─────────────────────────────────────────────────────────────────────
//  POLYGON MODE
// ─────────────────────────────────────────────────────────────────────

function addPolyPoint(wx, wy) {
  // Snap-to-close: if near first point (in world units), commit
  if (polyPoints.length >= 3) {
    const dx = wx - polyPoints[0].x;
    const dy = wy - polyPoints[0].y;
    if (Math.sqrt(dx * dx + dy * dy) < 22 / camera.zoom) {
      commitPolygon();
      return;
    }
  }
  polyPoints.push({ x: wx, y: wy });
  scheduleRender();
}

function commitPolygon() {
  if (polyPoints.length < 3) return;
  pushUndo();
  const s = getSettings();
  history.push({
    type: 'polygon',
    points: polyPoints.map(p => ({ ...p })),
    symmetry,
    color: currentColor,
    size: s.size,
    opacity: s.opacity,
    lineCap: s.lineCap,
    glow: glowEnabled,
  });
  polyPoints = [];
  scheduleRender();
}

// ─────────────────────────────────────────────────────────────────────
//  SAVE
// ─────────────────────────────────────────────────────────────────────

function saveImage() {
  renderAll();  // ensure up to date
  const link = document.createElement('a');
  link.download = 'mandala-' + Date.now() + '.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
}

// ─────────────────────────────────────────────────────────────────────
//  POINTER EVENTS
// ─────────────────────────────────────────────────────────────────────

function getEventPos(e) {
  if (e.touches && e.touches.length > 0) {
    return { x: e.touches[0].clientX, y: e.touches[0].clientY, button: 0 };
  }
  return { x: e.clientX, y: e.clientY, button: e.button };
}

canvas.addEventListener('contextmenu', e => e.preventDefault());

canvas.addEventListener('pointerdown', e => {
  canvas.setPointerCapture(e.pointerId);
  const pos = getEventPos(e);

  // ── PAN: middle mouse (button=1) or right mouse (button=2) ──
  if (e.button === 1 || e.button === 2) {
    isPanning = true;
    panStart = { x: pos.x, y: pos.y, px: camera.panX, py: camera.panY };
    canvas.style.cursor = 'grab';
    e.preventDefault();
    return;
  }

  // ── DRAW: left mouse ──
  const w = screenToWorld(pos.x, pos.y);

  if (mode === 'string')  { addPin(w.x, w.y); return; }
  if (mode === 'polygon') { addPolyPoint(w.x, w.y); return; }

  const s = getSettings();
  pushUndo();

  liveStroke = {
    type: 'stroke',
    mode,
    points: [{ x: w.x, y: w.y }],
    color: currentColor,
    size: s.size,
    opacity: s.opacity,
    lineCap: s.lineCap,
    glow: glowEnabled,
    symmetry,
    spiralAngleDeg: s.spiralAngleDeg,
    spiralScale: s.spiralScale,
    spiralStrokeIndex: spiralStrokeCount,
  };
  isDrawing = true;
  e.preventDefault();
});

canvas.addEventListener('pointermove', e => {
  const pos = getEventPos(e);

  if (isPanning) {
    // Update pan offset (simple translation)
    camera.panX = panStart.px + (pos.x - panStart.x);
    camera.panY = panStart.py + (pos.y - panStart.y);
    scheduleRender();
    return;
  }

  if (!isDrawing || !liveStroke) return;

  const w = screenToWorld(pos.x, pos.y);
  liveStroke.points.push({ x: w.x, y: w.y });

  // Draw immediately (no scheduling) for lowest latency feel
  renderAll();
  e.preventDefault();
});

function commitDrawing() {
  if (isDrawing && liveStroke) {
    if (liveStroke.points.length > 1) {
      history.push(liveStroke);
      if (liveStroke.mode === 'spiral') spiralStrokeCount++;
    }
    liveStroke = null;
    isDrawing = false;
    scheduleRender();
  }
}

canvas.addEventListener('pointerup', e => {
  if (isPanning) { isPanning = false; canvas.style.cursor = 'crosshair'; return; }
  commitDrawing();
});

canvas.addEventListener('pointerleave', () => {
  if (isPanning) { isPanning = false; canvas.style.cursor = 'crosshair'; }
  commitDrawing();
});

canvas.addEventListener('pointercancel', () => {
  isPanning = false; isDrawing = false; liveStroke = null;
  canvas.style.cursor = 'crosshair';
});

// Double-click to commit polygon
canvas.addEventListener('dblclick', () => {
  if (mode === 'polygon') commitPolygon();
});

// ─── MOUSE WHEEL ZOOM ────────────────────────────────────────────────
canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const factor = e.deltaY < 0 ? 1.13 : 1 / 1.13;
  zoomAt(e.clientX, e.clientY, factor);
}, { passive: false });

// ─── PINCH-TO-ZOOM (touch) ───────────────────────────────────────────
let lastTouchDist = null;
let lastTouchMid  = null;

canvas.addEventListener('touchstart', e => {
  if (e.touches.length === 2) {
    lastTouchDist = getTouchDist(e);
    lastTouchMid  = getTouchMid(e);
    e.preventDefault();
  }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  if (e.touches.length === 2 && lastTouchDist) {
    const dist = getTouchDist(e);
    const mid  = getTouchMid(e);
    zoomAt(mid.x, mid.y, dist / lastTouchDist);
    camera.panX += mid.x - lastTouchMid.x;
    camera.panY += mid.y - lastTouchMid.y;
    lastTouchDist = dist;
    lastTouchMid  = mid;
    e.preventDefault();
  }
}, { passive: false });

canvas.addEventListener('touchend', () => { lastTouchDist = null; lastTouchMid = null; });

function getTouchDist(e) {
  const dx = e.touches[0].clientX - e.touches[1].clientX;
  const dy = e.touches[0].clientY - e.touches[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}
function getTouchMid(e) {
  return {
    x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
    y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
  };
}

// ─────────────────────────────────────────────────────────────────────
//  WINDOW RESIZE
// ─────────────────────────────────────────────────────────────────────

window.addEventListener('resize', () => {
  canvas.width  = window.innerWidth;
  canvas.height = window.innerHeight;
  scheduleRender();
});

// ─────────────────────────────────────────────────────────────────────
//  HINT AUTO-HIDE
// ─────────────────────────────────────────────────────────────────────

const hint = document.getElementById('hint');
setTimeout(() => { hint.style.opacity = '0'; }, 5000);
setTimeout(() => { hint.style.display = 'none'; }, 6300);

// ─────────────────────────────────────────────────────────────────────
//  INIT
// ─────────────────────────────────────────────────────────────────────

canvas.width  = window.innerWidth;
canvas.height = window.innerHeight;

setMode('symmetry');
setSymmetry(6);
updateZoomLabel();
renderAll();
</script>
</body>
</html>
